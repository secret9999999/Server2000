From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Janet Blackquill <uhhadd@gmail.com>
Date: Sat, 18 May 2024 21:34:59 -0400
Subject: [PATCH] Implement preliminary API for working with brains AI


diff --git a/src/main/java/io/papermc/paper/entity/PaperActivity.java b/src/main/java/io/papermc/paper/entity/PaperActivity.java
new file mode 100644
index 0000000000000000000000000000000000000000..98916794a4e9f4316d9f0bbb824a40990e3879e7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/PaperActivity.java
@@ -0,0 +1,36 @@
+package io.papermc.paper.entity.ai;
+
+import net.minecraft.world.entity.schedule.Activity;
+import net.minecraft.core.registries.Registries;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Registry;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.Handleable;
+
+public class PaperActivity implements io.papermc.paper.entity.ai.Activity, Handleable<Activity> {
+    final private NamespacedKey key;
+    final private Activity handle;
+
+    public static io.papermc.paper.entity.ai.Activity minecraftToBukkit(Activity minecraft) {
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ACTIVITY, Registry.ACTIVITY);
+    }
+    public static Activity bukkitToMinecraft(io.papermc.paper.entity.ai.Activity bukkit) {
+        return CraftRegistry.bukkitToMinecraft(bukkit);
+    }
+
+    public PaperActivity(NamespacedKey key, Activity handle) {
+        this.key = key;
+        this.handle = handle;
+    }
+
+    @Override
+    public Activity getHandle() {
+        return this.handle;
+    }
+
+    @Override
+    public NamespacedKey getKey() {
+        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.ACTIVITY.getKey(this), () -> this + " doesn't have a key");
+        return this.key;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/entity/PaperBrain.java b/src/main/java/io/papermc/paper/entity/PaperBrain.java
new file mode 100644
index 0000000000000000000000000000000000000000..911c2370e2ee97e3a29a136f34abf3601127ed34
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/PaperBrain.java
@@ -0,0 +1,77 @@
+package io.papermc.paper.entity.ai;
+
+import java.util.List;
+import org.bukkit.entity.LivingEntity;
+import net.minecraft.world.entity.ai.Brain;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import com.google.common.collect.ImmutableList;
+import net.minecraft.world.entity.ai.behavior.BehaviorControl;
+import org.jetbrains.annotations.NotNull;
+import org.bukkit.entity.Entity;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.Location;
+import net.minecraft.world.entity.ai.memory.WalkTarget;
+import org.bukkit.craftbukkit.util.CraftLocation;
+
+public class PaperBrain<Paper extends LivingEntity, Minecraft extends net.minecraft.world.entity.LivingEntity> implements io.papermc.paper.entity.ai.Brain<Paper> {
+    public final Brain<Minecraft> handle;
+
+    public PaperBrain(Brain<Minecraft> handle) {
+        this.handle = handle;
+    }
+    public Brain<Minecraft> getHandle() {
+        return this.handle;
+    }
+
+    @Override
+    public void useDefaultActivity() {
+        this.getHandle().useDefaultActivity();
+    }
+
+    @Override
+    public void useActivityIfPossible(@NotNull Activity activity) {
+        this.getHandle().setActiveActivityIfPossible(((PaperActivity)activity).getHandle());
+    }
+
+    @Override
+    public void setTasksForActivity(@NotNull Activity activity, int begin, @NotNull List<Task<Paper>> tasks) {
+        this.getHandle().addActivity(
+            ((PaperActivity)activity).getHandle(),
+            begin,
+            ImmutableList.<BehaviorControl<Minecraft>>copyOf(tasks.stream().map(task -> ((PaperTask<Paper, Minecraft>)task).getHandle()).iterator())
+        );
+    }
+
+    @Override
+    public void setSensors(@NotNull List<SensorType<Paper>> sensors) {
+        this.getHandle().setSensors(
+        	sensors.stream().map(sensor -> ((PaperSensorType<Paper, net.minecraft.world.entity.ai.sensing.Sensor<Minecraft>>)sensor).getHandle()).toList()
+        );
+    }
+
+    @Override
+    public void clearActivities() {
+        this.getHandle().removeAllBehaviors();
+    }
+
+    @Override
+    public void setDefaultActivity(@NotNull Activity activity) {
+        this.getHandle().setDefaultActivity(((PaperActivity)activity).getHandle());
+    }
+
+    @Override
+    public boolean isActive(@NotNull Activity activity) {
+        return this.getHandle().isActive(((PaperActivity)activity).getHandle());
+    }
+
+    @Override
+    public void setWalkTarget(@NotNull Location location, float speed, int completeWithinDistance) {
+        this.getHandle().setMemory(MemoryModuleType.WALK_TARGET, new WalkTarget(CraftLocation.toBlockPosition(location), speed, completeWithinDistance));
+    }
+
+    @Override
+    public void setWalkTarget(@NotNull Entity entity, float speed, int completeWithinDistance) {
+        this.getHandle().setMemory(MemoryModuleType.WALK_TARGET, new WalkTarget(((CraftEntity)entity).getHandle(), speed, completeWithinDistance));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/entity/PaperSensorType.java b/src/main/java/io/papermc/paper/entity/PaperSensorType.java
new file mode 100644
index 0000000000000000000000000000000000000000..a36a1855cb9b0098b1e8c7761f6d5a201421b1be
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/PaperSensorType.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.entity.ai;
+
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.NamespacedKey;
+import net.minecraft.world.entity.ai.sensing.Sensor;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import org.bukkit.craftbukkit.util.Handleable;
+
+public class PaperSensorType<Paper extends LivingEntity, Minecraft extends Sensor<?>> implements io.papermc.paper.entity.ai.SensorType<Paper>, Handleable<SensorType<Minecraft>> {
+    final private NamespacedKey key;
+    final private SensorType<Minecraft> handle;
+
+    public PaperSensorType(NamespacedKey key, SensorType<Minecraft> handle) {
+        this.key = key;
+        this.handle = handle;
+    }
+    public SensorType<Minecraft> getHandle() {
+        return this.handle;
+    }
+
+    @Override
+    public NamespacedKey getKey() {
+        if (true) java.util.Objects.requireNonNull(org.bukkit.Registry.SENSOR_TYPE.getKey(this), () -> this + " doesn't have a key");
+        return this.key;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/entity/PaperTask.java b/src/main/java/io/papermc/paper/entity/PaperTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..870ff6a179b62302c1b6dbf603fd5621396dd964
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/PaperTask.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.entity.ai;
+
+import org.bukkit.entity.LivingEntity;
+
+import net.minecraft.world.entity.ai.behavior.BehaviorControl;
+
+public class PaperTask<Paper extends LivingEntity, Minecraft extends net.minecraft.world.entity.LivingEntity> implements io.papermc.paper.entity.ai.Task {
+    final private BehaviorControl<Minecraft> handle;
+
+    public PaperTask(BehaviorControl<Minecraft> handle) {
+        this.handle = handle;
+    }
+    public BehaviorControl<Minecraft> getHandle() {
+        return this.handle;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/entity/PaperTasks.java b/src/main/java/io/papermc/paper/entity/PaperTasks.java
new file mode 100644
index 0000000000000000000000000000000000000000..433fcfdbb0b0112f2e80e71fc9bea19ad62d32b5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/PaperTasks.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.entity.ai;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Mob;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+import net.minecraft.world.entity.ai.behavior.BehaviorControl;
+import net.minecraft.world.entity.ai.behavior.MoveToTargetSink;
+import net.minecraft.world.entity.ai.behavior.LookAtTargetSink;
+import net.minecraft.world.entity.ai.behavior.Swim;
+import net.minecraft.world.entity.ai.behavior.AnimalPanic;
+import net.minecraft.world.entity.ai.behavior.SetEntityLookTarget;
+import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromLookTarget;
+import net.minecraft.world.entity.ai.behavior.RunOne;
+import org.bukkit.craftbukkit.entity.memory.CraftMemoryKey;
+import org.jetbrains.annotations.NotNull;
+import java.util.function.Predicate;
+import java.util.function.Function;
+import java.util.Map;
+import java.util.List;
+import java.util.ArrayList;
+import com.mojang.datafixers.util.Pair;
+
+public class PaperTasks implements io.papermc.paper.entity.ai.Tasks {
+    public <Entity extends Mob> @NotNull Task<Entity> walkToWalkTarget(int minRunTime, int maxRunTime) {
+        return new PaperTask(new MoveToTargetSink(minRunTime, maxRunTime));
+    }
+    public <Entity extends Mob> @NotNull Task<Entity> swimIfInWater(float chance) {
+        return new PaperTask(new Swim(chance));
+    }
+    public <Entity extends Mob> @NotNull Task<Entity> panicOnDamage(float speed) {
+        return new PaperTask(new AnimalPanic(speed));
+    }
+    public <Entity extends LivingEntity> @NotNull Task<Entity> setLookTarget(Predicate<LivingEntity> predicate, float maximumDistance) {
+        return new PaperTask(SetEntityLookTarget.create(nmsEntity -> predicate.test(nmsEntity.getBukkitLivingEntity()), maximumDistance));
+    }
+    public <Entity extends LivingEntity> @NotNull Task<Entity> setWalkTargetToLookTarget(Predicate<LivingEntity> predicate, Function<LivingEntity, Float> speed, int completionRange) {
+        return new PaperTask(SetWalkTargetFromLookTarget.create(
+            nmsEntity -> predicate.test(nmsEntity.getBukkitLivingEntity()),
+            nmsEntity -> speed.apply(nmsEntity.getBukkitLivingEntity()),
+            completionRange
+        ));
+    }
+    public <Entity extends Mob> @NotNull Task<Entity> lookAtLookTarget(int minRunTime, int maxRunTime) {
+        return new PaperTask(new LookAtTargetSink(minRunTime, maxRunTime));
+    }
+    public <Bukkit extends LivingEntity> @NotNull Task<Bukkit> runOneOf(Map<Task<? super Bukkit>, Integer> tasks) {
+        List<Pair<BehaviorControl<? super net.minecraft.world.entity.LivingEntity>, Integer>> mcTasks = new ArrayList<>(tasks.size());
+        for (Map.Entry<Task<? super Bukkit>, Integer> entry : tasks.entrySet()) {
+            mcTasks.add(new Pair(((PaperTask)entry.getKey()).getHandle(), entry.getValue()));
+        }
+        return new PaperTask(new RunOne(mcTasks));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/registry/PaperRegistries.java b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
index 3aa5aec0b17cbdff922009b940d49bb06945c2c6..0a151079c94bead42bb84b2ce331fa71ae7ae0fc 100644
--- a/src/main/java/io/papermc/paper/registry/PaperRegistries.java
+++ b/src/main/java/io/papermc/paper/registry/PaperRegistries.java
@@ -38,7 +38,10 @@ import org.bukkit.potion.PotionEffectType;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.framework.qual.DefaultQualifier;
-
+import io.papermc.paper.entity.ai.Activity;
+import io.papermc.paper.entity.ai.PaperActivity;
+import io.papermc.paper.entity.ai.SensorType;
+import io.papermc.paper.entity.ai.PaperSensorType;
 import static io.papermc.paper.registry.entry.RegistryEntry.apiOnly;
 import static io.papermc.paper.registry.entry.RegistryEntry.entry;
 
@@ -64,6 +67,8 @@ public final class PaperRegistries {
             entry(Registries.STRUCTURE_TYPE, RegistryKey.STRUCTURE_TYPE, StructureType.class, CraftStructureType::new),
             entry(Registries.BLOCK, RegistryKey.BLOCK, BlockType.class, CraftBlockType::new),
             entry(Registries.ITEM, RegistryKey.ITEM, ItemType.class, CraftItemType::new),
+            entry(Registries.ACTIVITY, RegistryKey.ACTIVITY, Activity.class, PaperActivity::new),
+            entry(Registries.SENSOR_TYPE, (RegistryKey<SensorType>)(Object)RegistryKey.SENSOR_TYPE, SensorType.class, PaperSensorType::new),
 
             // data-drivens
             entry(Registries.STRUCTURE, RegistryKey.STRUCTURE, Structure.class, CraftStructure::new).delayed(),
diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
index afbb027021acfbe25d534a84f1750e420bbde6e0..f27ab489a833922bf6647048b6d96a78fbeb9a2f 100644
--- a/src/main/java/net/minecraft/world/entity/ai/Brain.java
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -79,7 +79,7 @@ public class Brain<E extends LivingEntity> {
                     }
 
                     public <T> DataResult<Brain<E>> decode(DynamicOps<T> dynamicOps, MapLike<T> mapLike) {
-                        MutableObject<DataResult<Builder<Brain.MemoryValue<?>>>> mutableObject = new MutableObject<>(
+                        MutableObject<DataResult<Builder<Brain.MemoryValue<?>>>> dataResultMutableObject = new MutableObject<>( // Paper - fix decompilation name collision
                             DataResult.success(ImmutableList.builder())
                         );
                         mapLike.entries()
@@ -91,10 +91,10 @@ public class Brain<E extends LivingEntity> {
                                     DataResult<? extends Brain.MemoryValue<?>> dataResult2 = dataResult.flatMap(
                                         memoryType -> this.captureRead((MemoryModuleType<T>)memoryType, dynamicOps, (T)pair.getSecond())
                                     );
-                                    mutableObject.setValue(mutableObject.getValue().apply2(Builder::add, dataResult2));
+                                    dataResultMutableObject.setValue(dataResultMutableObject.getValue().apply2(Builder::add, dataResult2)); // Paper - fix decompilation name collision
                                 }
                             );
-                        ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject.getValue()
+                        ImmutableList<Brain.MemoryValue<?>> immutableList = dataResultMutableObject.getValue() // Paper - fix decompilation name collision
                             .resultOrPartial(Brain.LOGGER::error)
                             .map(Builder::build)
                             .orElseGet(ImmutableList::of);
@@ -147,6 +147,15 @@ public class Brain<E extends LivingEntity> {
         }
     }
 
+    // Paper start - allow overriding sensors
+    public void setSensors(Collection<? extends SensorType<? extends Sensor<? super E>>> newSensors) {
+        this.sensors.clear();
+        for (SensorType<? extends Sensor<? super E>> sensorType : newSensors) {
+            this.sensors.put(sensorType, (Sensor<? super E>)sensorType.create());
+        }
+    }
+    // Paper end
+
     public <T> DataResult<T> serializeStart(DynamicOps<T> ops) {
         return this.codec.get().encodeStart(ops, this);
     }
@@ -180,28 +189,30 @@ public class Brain<E extends LivingEntity> {
     }
 
     <U> void setMemoryInternal(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> memory) {
-        if (this.memories.containsKey(type)) {
+        // Paper start - allow custom memories to be set on any brain
+        // if (this.memories.containsKey(type)) {
             if (memory.isPresent() && this.isEmptyCollection(memory.get().getValue())) {
                 this.eraseMemory(type);
             } else {
                 this.memories.put(type, memory);
             }
-        }
+        // }
+        // Paper end - allow custom memories to be set on any brain
     }
 
     public <U> Optional<U> getMemory(MemoryModuleType<U> type) {
-        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
+        Optional<? extends ExpirableValue<?>> optional = (Optional<? extends ExpirableValue<U>>)this.memories.get(type); // Paper - decompilation fix
         if (optional == null) {
             throw new IllegalStateException("Unregistered memory fetched: " + type);
         } else {
-            return optional.map(ExpirableValue::getValue);
+            return optional.map(x -> (U)x.getValue()); // Paper - decompilation fix
         }
     }
 
     @Nullable
     public <U> Optional<U> getMemoryInternal(MemoryModuleType<U> type) {
-        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
-        return optional == null ? null : optional.map(ExpirableValue::getValue);
+        Optional<? extends ExpirableValue<?>> optional = (Optional<? extends ExpirableValue<U>>)this.memories.get(type); // Paper - decompilation fix
+        return optional == null ? null : optional.map(x -> (U)x.getValue()); // Paper - decompilation fix
     }
 
     public <U> long getTimeUntilExpiry(MemoryModuleType<U> type) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 2fa5507aa2153a05208077f9547c165a1099b5bb..da0c4fca4290b17259e286de477d9ac3c291338f 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -3264,4 +3264,17 @@ public final class CraftServer implements Server {
         return this.potionBrewer;
     }
     // Paper end
+    // Paper begin - activities and tasks AI API
+    private final io.papermc.paper.entity.ai.Tasks tasks = new io.papermc.paper.entity.ai.PaperTasks();
+
+    @Override
+    public io.papermc.paper.entity.ai.Tasks getTasks() {
+        return this.tasks;
+    }
+
+    @Override
+    public <E extends org.bukkit.entity.LivingEntity> io.papermc.paper.entity.ai.Brain<E> getBrain(E entity) {
+        return new io.papermc.paper.entity.ai.PaperBrain(((org.bukkit.craftbukkit.entity.CraftLivingEntity)entity).getHandle().getBrain());
+    }
+    // Paper end - activities and tasks AI API
 }
diff --git a/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java b/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
index 24f01242513d6c815f60599d7118fe12bc577804..10d024545ff14db4366386a8337f02769fbf8dce 100644
--- a/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
+++ b/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
@@ -55,7 +55,7 @@ public class RegistriesArgumentProvider implements ArgumentsProvider {
         register(RegistryKey.WOLF_VARIANT, Wolf.Variant.class, Registries.WOLF_VARIANT, CraftWolf.CraftVariant.class, WolfVariant.class);
         register(RegistryKey.ITEM, ItemType.class, Registries.ITEM, CraftItemType.class, net.minecraft.world.item.Item.class, true);
         register(RegistryKey.BLOCK, BlockType.class, Registries.BLOCK, CraftBlockType.class, net.minecraft.world.level.block.Block.class, true);
-
+        register(RegistryKey.ACTIVITY, io.papermc.paper.entity.ai.Activity.class, Registries.ACTIVITY, io.papermc.paper.entity.ai.PaperActivity.class, net.minecraft.world.entity.schedule.Activity.class, true);
     }
 
     private static void register(RegistryKey registryKey, Class bukkit, ResourceKey registry, Class craft, Class minecraft) { // Paper
